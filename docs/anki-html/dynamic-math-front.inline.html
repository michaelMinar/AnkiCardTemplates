<div id="card-root"></div>
<!-- Safe field injection: use data attributes + JSON script to avoid breaking JS strings -->
<div id="dynamic-fields" data-template-id="{{TemplateId}}" data-seed="{{Seed}}"></div>
<script id="dynamic-config" type="application/json">{{Config}}</script>
<script>
// Dynamic Math bundle (runtime + templates)

"use strict";
(() => {
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };

  // src/runtime/rng.js
  var require_rng = __commonJS({
    "src/runtime/rng.js"(exports, module) {
      "use strict";
      function mulberry32(seed) {
        let t = seed >>> 0;
        return function() {
          t += 1831565813;
          let r = Math.imul(t ^ t >>> 15, 1 | t);
          r ^= r + Math.imul(r ^ r >>> 7, 61 | r);
          return ((r ^ r >>> 14) >>> 0) / 4294967296;
        };
      }
      function randInt(rng, min, max) {
        if (max < min) throw new Error("randInt: max < min");
        const r = rng();
        return Math.floor(r * (max - min + 1)) + min;
      }
      function choice(rng, arr) {
        if (!Array.isArray(arr) || arr.length === 0) throw new Error("choice: empty array");
        const idx = Math.floor(rng() * arr.length);
        return arr[idx];
      }
      function shuffle(rng, arr) {
        const a = arr.slice();
        for (let i = a.length - 1; i > 0; i--) {
          const j = Math.floor(rng() * (i + 1));
          const tmp = a[i];
          a[i] = a[j];
          a[j] = tmp;
        }
        return a;
      }
      function gcd(a, b) {
        a = Math.abs(a | 0);
        b = Math.abs(b | 0);
        while (b !== 0) {
          const t = b;
          b = a % b;
          a = t;
        }
        return a;
      }
      function lcm(a, b) {
        if (a === 0 || b === 0) return 0;
        return Math.abs(a * b / gcd(a, b));
      }
      module.exports = {
        mulberry32,
        randInt,
        choice,
        shuffle,
        gcd,
        lcm
      };
    }
  });

  // src/runtime/reviewSeed.js
  var require_reviewSeed = __commonJS({
    "src/runtime/reviewSeed.js"(exports, module) {
      "use strict";
      var seedCounter = 1;
      function getStorage() {
        try {
          if (typeof window !== "undefined" && window.sessionStorage) return window.sessionStorage;
        } catch (_) {
        }
        try {
          if (typeof sessionStorage !== "undefined") return sessionStorage;
        } catch (_) {
        }
        try {
          if (typeof window !== "undefined" && window.localStorage) return window.localStorage;
        } catch (_) {
        }
        try {
          if (typeof localStorage !== "undefined") return localStorage;
        } catch (_) {
        }
        const mem = /* @__PURE__ */ new Map();
        return {
          getItem: (k) => mem.has(k) ? String(mem.get(k)) : null,
          setItem: (k, v) => void mem.set(k, String(v)),
          removeItem: (k) => void mem.delete(k)
        };
      }
      function storageKey(templateId) {
        return `anki.seed.${templateId}`;
      }
      function coerceSeed(val) {
        if (typeof val === "number" && Number.isFinite(val)) return val >>> 0;
        if (typeof val === "string" && val.trim() !== "") {
          const n = parseInt(val, 10);
          if (!Number.isNaN(n)) return n >>> 0;
        }
        return null;
      }
      function freshSeed() {
        const now = Date.now() >>> 0;
        const extra = typeof performance !== "undefined" && typeof performance.now === "function" ? Math.floor(performance.now()) >>> 0 : 0;
        let salt = 0;
        try {
          if (typeof crypto !== "undefined" && typeof crypto.getRandomValues === "function") {
            const arr = new Uint32Array(1);
            crypto.getRandomValues(arr);
            salt = arr[0] >>> 0;
          }
        } catch (_) {
        }
        let s = (now ^ extra ^ seedCounter++ >>> 0 ^ salt) >>> 0;
        if (s === 0) s = 1;
        return s;
      }
      function resolveReviewSeed({ templateId, seedField, side = "front", perReview = true }) {
        if (!templateId || typeof templateId !== "string") {
          throw new Error("resolveReviewSeed: templateId is required");
        }
        const provided = coerceSeed(seedField);
        const key = storageKey(templateId);
        const store = getStorage();
        if (typeof provided === "number") {
          try {
            store.removeItem(key);
          } catch (_) {
          }
          return provided;
        }
        if (!perReview) {
          return freshSeed();
        }
        if (side === "front") {
          const s2 = freshSeed();
          try {
            store.setItem(key, String(s2));
          } catch (_) {
          }
          return s2;
        }
        try {
          const v = store.getItem(key);
          const s2 = coerceSeed(v);
          if (typeof s2 === "number") {
            try {
              store.removeItem(key);
            } catch (_) {
            }
            return s2;
          }
        } catch (_) {
        }
        const s = freshSeed();
        return s;
      }
      module.exports = {
        resolveReviewSeed,
        _internal: { storageKey, getStorage, freshSeed, coerceSeed }
      };
    }
  });

  // src/runtime/index.js
  var require_runtime = __commonJS({
    "src/runtime/index.js"(exports, module) {
      "use strict";
      var rng = require_rng();
      var reviewSeed = require_reviewSeed();
      var REGISTRY = /* @__PURE__ */ Object.create(null);
      function registerTemplate(id, impl) {
        if (!id || typeof id !== "string") {
          throw new Error("registerTemplate: id must be a non-empty string");
        }
        if (!impl || typeof impl.generate !== "function") {
          throw new Error("registerTemplate: impl must include generate(opts)");
        }
        if (impl.id && impl.id !== id) {
          throw new Error("registerTemplate: impl.id must match id");
        }
        REGISTRY[id] = impl;
        return impl;
      }
      function getTemplate(id) {
        const t = REGISTRY[id];
        if (!t) throw new Error(`Unknown template: ${id}`);
        return t;
      }
      if (typeof window !== "undefined") {
        window.ANKI_TEMPLATES = {
          register: registerTemplate,
          get: getTemplate,
          util: {
            mulberry32: rng.mulberry32,
            randInt: rng.randInt,
            choice: rng.choice,
            shuffle: rng.shuffle,
            gcd: rng.gcd,
            lcm: rng.lcm,
            resolveReviewSeed: reviewSeed.resolveReviewSeed
          }
        };
      }
      module.exports = {
        registerTemplate,
        getTemplate,
        util: Object.assign({}, rng, { resolveReviewSeed: reviewSeed.resolveReviewSeed })
      };
    }
  });

  // src/templates/_starter/add_two_numbers.js
  var require_add_two_numbers = __commonJS({
    "src/templates/_starter/add_two_numbers.js"(exports, module) {
      "use strict";
      var { mulberry32, randInt } = require_rng();
      var { registerTemplate } = require_runtime();
      var id = "topic/add_two_numbers";
      var meta = {
        title: "Add Two Numbers",
        skills: ["addition"],
        gradeBands: [2, 3],
        defaults: { min: 2, max: 12 }
      };
      function generate({ seed, config = {}, side = "front" }) {
        if (typeof seed !== "number") {
          throw new Error("generate: seed (number) is required");
        }
        const { min = meta.defaults.min, max = meta.defaults.max } = config || {};
        const rng = mulberry32(seed);
        const a = randInt(rng, min, max);
        const b = randInt(rng, min, max);
        const answer = a + b;
        const htmlFront = `<div class="q">${a} + ${b} = ?</div>`;
        if (side !== "back") {
          return { html: htmlFront, data: { a, b } };
        }
        const htmlBack = `<div class="q">${a} + ${b} = <b>${answer}</b></div>`;
        return { html: htmlBack, data: { a, b, answer } };
      }
      function validate({ seed, config = {} }) {
        try {
          const { min = meta.defaults.min, max = meta.defaults.max } = config || {};
          const rng = mulberry32(seed);
          const a = randInt(rng, min, max);
          const b = randInt(rng, min, max);
          const ans = a + b;
          const ok = ans >= min * 2 && ans <= max * 2;
          return { ok, warnings: ok ? [] : ["answer out of expected range"] };
        } catch (e) {
          return { ok: false, errors: [String(e && e.message ? e.message : e)] };
        }
      }
      registerTemplate(id, { id, meta, generate, validate });
      module.exports = { id, meta, generate, validate };
    }
  });

  // src/templates/arithmetic/multiply_2d_by_1d.js
  var require_multiply_2d_by_1d = __commonJS({
    "src/templates/arithmetic/multiply_2d_by_1d.js"(exports, module) {
      "use strict";
      var { mulberry32, randInt } = require_rng();
      var { registerTemplate } = require_runtime();
      var id = "arithmetic/multiply_2d_by_1d";
      var meta = {
        title: "Multiply 2-digit by 1-digit",
        skills: ["multiplication"],
        gradeBands: [4, 5, 6],
        defaults: { twoDigitMin: 12, twoDigitMax: 99, oneDigitMin: 2, oneDigitMax: 9 }
      };
      function generate({ seed, config = {}, side = "front" }) {
        if (typeof seed !== "number") throw new Error("generate: seed (number) is required");
        const {
          twoDigitMin = meta.defaults.twoDigitMin,
          twoDigitMax = meta.defaults.twoDigitMax,
          oneDigitMin = meta.defaults.oneDigitMin,
          oneDigitMax = meta.defaults.oneDigitMax
        } = config || {};
        const rng = mulberry32(seed);
        const a = randInt(rng, twoDigitMin, twoDigitMax);
        const b = randInt(rng, oneDigitMin, oneDigitMax);
        const answer = a * b;
        const front = `<div class="q">${a} \xD7 ${b} = ?</div>`;
        if (side !== "back") return { html: front, data: { a, b } };
        const back = `<div class="q">${a} \xD7 ${b} = <b>${answer}</b></div>`;
        return { html: back, data: { a, b, answer } };
      }
      function validate({ seed, config = {} }) {
        try {
          const {
            twoDigitMin = meta.defaults.twoDigitMin,
            twoDigitMax = meta.defaults.twoDigitMax,
            oneDigitMin = meta.defaults.oneDigitMin,
            oneDigitMax = meta.defaults.oneDigitMax
          } = config || {};
          const rng = mulberry32(seed);
          const a = randInt(rng, twoDigitMin, twoDigitMax);
          const b = randInt(rng, oneDigitMin, oneDigitMax);
          const ans = a * b;
          const ok = a >= twoDigitMin && a <= twoDigitMax && b >= oneDigitMin && b <= oneDigitMax && ans > 0;
          return { ok, warnings: ok ? [] : ["operands out of range or non-positive answer"] };
        } catch (e) {
          return { ok: false, errors: [String(e && e.message ? e.message : e)] };
        }
      }
      registerTemplate(id, { id, meta, generate, validate });
      module.exports = { id, meta, generate, validate };
    }
  });

  // src/templates/number_theory/gcf_basic.js
  var require_gcf_basic = __commonJS({
    "src/templates/number_theory/gcf_basic.js"(exports, module) {
      "use strict";
      var { mulberry32, randInt, choice, gcd } = require_rng();
      var { registerTemplate } = require_runtime();
      var id = "number_theory/gcf_basic";
      var meta = {
        title: "Greatest Common Factor (2 numbers)",
        skills: ["number-theory", "gcf", "factors"],
        gradeBands: [5, 6],
        defaults: {
          digits: [2, 3],
          // choose 2- or 3-digit operands
          ensureNonTrivial: true
          // bias toward GCF > 1
        }
      };
      function normalizeDigitsCfg(cfgDigits) {
        if (Array.isArray(cfgDigits) && cfgDigits.length > 0) {
          return cfgDigits.filter((d) => d === 2 || d === 3);
        }
        if (cfgDigits === 2 || cfgDigits === 3) return [cfgDigits];
        return [2, 3];
      }
      function rangeFromDigits(d) {
        if (d === 2) return { min: 10, max: 99 };
        if (d === 3) return { min: 100, max: 999 };
        return { min: 10, max: 99 };
      }
      function pickMultipleOf(rng, prime, min, max) {
        const first = Math.ceil(min / prime) * prime;
        if (first > max) return null;
        const count = Math.floor((max - first) / prime) + 1;
        const offset = randInt(rng, 0, count - 1);
        return first + offset * prime;
      }
      function generatePair(rng, config) {
        var _a, _b, _c;
        const digitsList = normalizeDigitsCfg((_a = config.digits) != null ? _a : meta.defaults.digits);
        const d = choice(rng, digitsList);
        const { min, max } = config.range && typeof config.range === "object" ? { min: Math.max(2, config.range.min | 0 || 2), max: config.range.max | 0 || (d === 3 ? 999 : 99) } : rangeFromDigits(d);
        const ensureNonTrivial = config.ensureNonTrivial !== false;
        const smallPrimes = [2, 3, 5, 7];
        const attempts = 20;
        let lastA = 12, lastB = 18;
        for (let i = 0; i < attempts; i++) {
          let a, b;
          if (ensureNonTrivial && rng() < 0.7) {
            const p = choice(rng, smallPrimes);
            a = (_b = pickMultipleOf(rng, p, min, max)) != null ? _b : randInt(rng, min, max);
            b = (_c = pickMultipleOf(rng, p, min, max)) != null ? _c : randInt(rng, min, max);
          } else {
            a = randInt(rng, min, max);
            b = randInt(rng, min, max);
          }
          if (a < 2) a = 2;
          if (b < 2) b = 2;
          const g = gcd(a, b);
          lastA = a;
          lastB = b;
          if (!ensureNonTrivial || g > 1) {
            return { a, b, g };
          }
        }
        return { a: lastA, b: lastB, g: gcd(lastA, lastB) };
      }
      function generate({ seed, config = {}, side = "front" }) {
        if (typeof seed !== "number") throw new Error("generate: seed (number) is required");
        const rng = mulberry32(seed);
        const { a, b, g } = generatePair(rng, config);
        const front = `<div class="q">GCF(${a}, ${b}) = ?</div>`;
        if (side !== "back") return { html: front, data: { a, b, answer: g } };
        const back = `<div class="q">GCF(${a}, ${b}) = <b>${g}</b></div>`;
        return { html: back, data: { a, b, answer: g } };
      }
      function validate({ seed, config = {} }) {
        try {
          const rng = mulberry32(seed);
          const { a, b, g } = generatePair(rng, config);
          const ok = a % g === 0 && b % g === 0 && g >= 1;
          const warnings = [];
          if (config.ensureNonTrivial !== false && g === 1) {
            warnings.push("gcf is 1 despite ensureNonTrivial bias");
          }
          return { ok, warnings };
        } catch (e) {
          return { ok: false, errors: [String(e && e.message ? e.message : e)] };
        }
      }
      registerTemplate(id, { id, meta, generate, validate });
      module.exports = { id, meta, generate, validate };
    }
  });

  // src/templates/number_theory/lcm_basic.js
  var require_lcm_basic = __commonJS({
    "src/templates/number_theory/lcm_basic.js"(exports, module) {
      "use strict";
      var { mulberry32, randInt, choice, gcd, lcm } = require_rng();
      var { registerTemplate } = require_runtime();
      var id = "number_theory/lcm_basic";
      var meta = {
        title: "Least Common Multiple (2\u20133 numbers)",
        skills: ["number-theory", "lcm", "multiples"],
        gradeBands: [5, 6],
        defaults: {
          count: 2,
          // operands: 2 or 3
          digits: [1, 2],
          // 1- or 2-digit by default
          ensureNonTrivial: true,
          lcmCap: 5e3
        }
      };
      function normalizeDigitsCfg(cfgDigits) {
        if (Array.isArray(cfgDigits) && cfgDigits.length > 0) {
          return cfgDigits.filter((d) => d === 1 || d === 2 || d === 3);
        }
        if (cfgDigits === 1 || cfgDigits === 2 || cfgDigits === 3) return [cfgDigits];
        return [1, 2];
      }
      function rangeFromDigits(d) {
        if (d === 1) return { min: 2, max: 9 };
        if (d === 2) return { min: 10, max: 99 };
        if (d === 3) return { min: 100, max: 999 };
        return { min: 2, max: 9 };
      }
      function pickMultipleOf(rng, prime, min, max) {
        const first = Math.ceil(min / prime) * prime;
        if (first > max) return null;
        const count = Math.floor((max - first) / prime) + 1;
        const offset = randInt(rng, 0, count - 1);
        return first + offset * prime;
      }
      function genOperands(rng, config) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _i;
        const digitsList = normalizeDigitsCfg((_a = config.digits) != null ? _a : meta.defaults.digits);
        const hasMultiDigit = digitsList.some((d) => d === 2 || d === 3);
        const rangeOverride = config.range && typeof config.range === "object" ? {
          min: typeof config.range.min === "number" ? Math.max(2, config.range.min | 0) : void 0,
          max: typeof config.range.max === "number" ? config.range.max | 0 : void 0
        } : null;
        const ensureNonTrivial = config.ensureNonTrivial !== false;
        const smallPrimes = [2, 3, 5, 7];
        const count = config.count === 3 ? 3 : 2;
        const attempts = 40;
        const cap = typeof config.lcmCap === "number" ? Math.max(1, config.lcmCap | 0) : meta.defaults.lcmCap;
        let lastOps = [2, 4];
        for (let i = 0; i < attempts; i++) {
          let ops = new Array(count);
          if (ensureNonTrivial && rng() < 0.7) {
            const p = choice(rng, smallPrimes);
            for (let k = 0; k < count; k++) {
              let rMin, rMax;
              if (rangeOverride && (rangeOverride.min || rangeOverride.max)) {
                rMin = (_b = rangeOverride.min) != null ? _b : 2;
                rMax = (_c = rangeOverride.max) != null ? _c : 999;
              } else {
                const dSel = choice(rng, digitsList);
                const r = rangeFromDigits(dSel);
                rMin = r.min;
                rMax = r.max;
              }
              const mult = pickMultipleOf(rng, p, rMin, rMax);
              ops[k] = mult != null ? mult : randInt(rng, rMin, rMax);
              if (ops[k] < 2) ops[k] = 2;
            }
            const shares = ops.filter((n) => n % p === 0).length;
            if (shares < 2) {
              let rMin, rMax;
              if (rangeOverride && (rangeOverride.min || rangeOverride.max)) {
                rMin = (_d = rangeOverride.min) != null ? _d : 2;
                rMax = (_e = rangeOverride.max) != null ? _e : 999;
              } else {
                const dSel = choice(rng, digitsList);
                const r = rangeFromDigits(dSel);
                rMin = r.min;
                rMax = r.max;
              }
              ops[1] = (_f = pickMultipleOf(rng, p, rMin, rMax)) != null ? _f : ops[1];
            }
          } else {
            for (let k = 0; k < count; k++) {
              let rMin, rMax;
              if (rangeOverride && (rangeOverride.min || rangeOverride.max)) {
                rMin = (_g = rangeOverride.min) != null ? _g : 2;
                rMax = (_h = rangeOverride.max) != null ? _h : 999;
              } else {
                const dSel = choice(rng, digitsList);
                const r = rangeFromDigits(dSel);
                rMin = r.min;
                rMax = r.max;
              }
              ops[k] = randInt(rng, rMin, rMax);
              if (ops[k] < 2) ops[k] = 2;
            }
          }
          if (count === 2 && !rangeOverride && hasMultiDigit) {
            if (ops[0] < 10 && ops[1] < 10) {
              const preferredDigits = digitsList.filter((d) => d === 2 || d === 3);
              const dAdj = preferredDigits.length ? choice(rng, preferredDigits) : 2;
              const rAdj = rangeFromDigits(dAdj);
              let newB;
              if (ensureNonTrivial) {
                const p = choice(rng, [2, 3, 5, 7]);
                newB = (_i = pickMultipleOf(rng, p, rAdj.min, rAdj.max)) != null ? _i : randInt(rng, rAdj.min, rAdj.max);
              } else {
                newB = randInt(rng, rAdj.min, rAdj.max);
              }
              ops[1] = newB < 2 ? 2 : newB;
            }
          }
          lastOps = ops;
          let ans2 = ops[0];
          for (let k = 1; k < ops.length; k++) ans2 = lcm(ans2, ops[k]);
          if (ans2 <= cap) {
            const g01 = gcd(ops[0], ops[1]);
            const nonTrivial = g01 > 1 || ops.length === 3 && (gcd(ops[0], ops[2]) > 1 || gcd(ops[1], ops[2]) > 1);
            if (!ensureNonTrivial || nonTrivial) {
              return { ops, ans: ans2 };
            }
          }
        }
        let ans = lastOps[0];
        for (let k = 1; k < lastOps.length; k++) ans = lcm(ans, lastOps[k]);
        return { ops: lastOps, ans };
      }
      function generate({ seed, config = {}, side = "front" }) {
        if (typeof seed !== "number") throw new Error("generate: seed (number) is required");
        const rng = mulberry32(seed);
        const { ops, ans } = genOperands(rng, config);
        const disp = ops.join(", ");
        const front = `<div class="q">LCM(${disp}) = ?</div>`;
        if (side !== "back") return { html: front, data: { operands: ops.slice(), answer: ans } };
        const back = `<div class="q">LCM(${disp}) = <b>${ans}</b></div>`;
        return { html: back, data: { operands: ops.slice(), answer: ans } };
      }
      function validate({ seed, config = {} }) {
        try {
          const rng = mulberry32(seed);
          const { ops, ans } = genOperands(rng, config);
          let ok = true;
          for (const n of ops) {
            if (ans % n !== 0) ok = false;
          }
          if ((config.count | 0) !== 3) {
            const a = ops[0], b = ops[1];
            if (a > 0 && b > 0) {
              const g = gcd(a, b);
              if (ans * g !== a * b) {
                ok = false;
              }
            }
          }
          const cap = typeof config.lcmCap === "number" ? Math.max(1, config.lcmCap | 0) : meta.defaults.lcmCap;
          const warnings = [];
          if (ans > cap) warnings.push("LCM exceeded cap; generation fell back to last sample");
          if (config.ensureNonTrivial !== false) {
            const nonTrivial = gcd(ops[0], ops[1]) > 1 || ops.length === 3 && (gcd(ops[0], ops[2]) > 1 || gcd(ops[1], ops[2]) > 1);
            if (!nonTrivial) warnings.push("operands likely coprime; LCM equals product for pairs");
          }
          return { ok, warnings };
        } catch (e) {
          return { ok: false, errors: [String(e && e.message ? e.message : e)] };
        }
      }
      registerTemplate(id, { id, meta, generate, validate });
      module.exports = { id, meta, generate, validate };
    }
  });

  // src/entry/bundle.js
  require_runtime();
  require_add_two_numbers();
  require_multiply_2d_by_1d();
  require_gcf_basic();
  require_lcm_basic();
  if (typeof window !== "undefined") {
    window.DYNAMIC_MATH_VERSION = "phase-3-internal";
  }
})();

</script>
<script>
(function () {
  try {
    var fieldsEl = document.getElementById('dynamic-fields');
    var id = (fieldsEl && fieldsEl.dataset ? String(fieldsEl.dataset.templateId || '').trim() : '');
    var seedField = (fieldsEl && fieldsEl.dataset ? String(fieldsEl.dataset.seed || '').trim() : '');
    var cfgEl = document.getElementById('dynamic-config');
    var cfgText = (cfgEl && typeof cfgEl.textContent === 'string') ? cfgEl.textContent.trim() : '';
    var config = {};
    if (cfgText) {
      try { config = JSON.parse(cfgText); } catch (e) { console.error("Invalid Config JSON; using defaults", e, cfgText); }
    }
    var api = window.ANKI_TEMPLATES;
    if (!api || !api.util || typeof api.get !== 'function') {
      var r = document.getElementById('card-root');
      if (r) r.textContent = 'Template error: dynamic bundle not loaded';
      return;
    }
    var tpl = api.get(id);
    // Per-review default: true when Seed is not numeric
    var seed = api.util.resolveReviewSeed({ templateId: id, seedField: seedField, side: 'front' });
    var res = tpl.generate({ seed: seed, config: config, side: 'front' });
    document.getElementById('card-root').innerHTML = res.html;
  } catch (e) {
    document.getElementById('card-root').textContent = 'Template error: ' + (e && e.message || e);
  }
})();
</script>
